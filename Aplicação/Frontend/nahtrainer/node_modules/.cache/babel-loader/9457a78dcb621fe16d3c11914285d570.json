{"ast":null,"code":"import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport { trackStream } from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport progressEventReducer from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\n\nconst fetchProgressDecorator = (total, fn) => {\n  const lengthComputable = total != null;\n  return loaded => setTimeout(() => fn({\n    lengthComputable,\n    total,\n    loaded\n  }));\n};\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function'; // used only inside the fetch adapter\n\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : async str => new Uint8Array(await new Response(str).arrayBuffer()));\n\nconst supportsRequestStream = isReadableStreamSupported && (() => {\n  let duplexAccessed = false;\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    }\n\n  }).headers.has('Content-Type');\n  return duplexAccessed && !hasContentType;\n})();\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\nconst supportsResponseStream = isReadableStreamSupported && !!(() => {\n  try {\n    return utils.isReadableStream(new Response('').body);\n  } catch (err) {// return undefined\n  }\n})();\nconst resolvers = {\n  stream: supportsResponseStream && (res => res.body)\n};\nisFetchSupported && (res => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? res => res[type]() : (_, config) => {\n      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n    });\n  });\n})(new Response());\n\nconst getBodyLength = async body => {\n  if (body == null) {\n    return 0;\n  }\n\n  if (utils.isBlob(body)) {\n    return body.size;\n  }\n\n  if (utils.isSpecCompliantForm(body)) {\n    return (await new Request(body).arrayBuffer()).byteLength;\n  }\n\n  if (utils.isArrayBufferView(body)) {\n    return body.byteLength;\n  }\n\n  if (utils.isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if (utils.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n};\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils.toFiniteNumber(headers.getContentLength());\n  return length == null ? getBodyLength(body) : length;\n};\n\nexport default isFetchSupported && (async config => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = resolveConfig(config);\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals([signal, cancelToken], timeout) : [];\n  let finished, request;\n\n  const onFinish = () => {\n    !finished && setTimeout(() => {\n      composedSignal && composedSignal.unsubscribe();\n    });\n    finished = true;\n  };\n\n  let requestContentLength;\n\n  try {\n    if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader);\n      }\n\n      if (_request.body) {\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(requestContentLength, progressEventReducer(onUploadProgress)), null, encodeText);\n      }\n    }\n\n    if (!utils.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'cors' : 'omit';\n    }\n\n    request = new Request(url, { ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      withCredentials\n    });\n    let response = await fetch(request);\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {\n      const options = {};\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n      const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n      response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(responseContentLength, progressEventReducer(onDownloadProgress, true)), isStreamResponse && onFinish, encodeText), options);\n    }\n\n    responseType = responseType || 'text';\n    let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n    !isStreamResponse && onFinish();\n    stopTimeout && stopTimeout();\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: AxiosHeaders.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      });\n    });\n  } catch (err) {\n    onFinish();\n\n    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\n      throw Object.assign(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request), {\n        cause: err.cause || err\n      });\n    }\n\n    throw AxiosError.from(err, err && err.code, config, request);\n  }\n});","map":{"version":3,"sources":["C:/Users/beatr/OneDrive/Documentos/Nah Trainer/projetoaps/Aplicação/Frontend/nahtrainer/node_modules/axios/lib/adapters/fetch.js"],"names":["platform","utils","AxiosError","composeSignals","trackStream","AxiosHeaders","progressEventReducer","resolveConfig","settle","fetchProgressDecorator","total","fn","lengthComputable","loaded","setTimeout","isFetchSupported","fetch","Request","Response","isReadableStreamSupported","ReadableStream","encodeText","TextEncoder","encoder","str","encode","Uint8Array","arrayBuffer","supportsRequestStream","duplexAccessed","hasContentType","origin","body","method","duplex","headers","has","DEFAULT_CHUNK_SIZE","supportsResponseStream","isReadableStream","err","resolvers","stream","res","forEach","type","isFunction","_","config","ERR_NOT_SUPPORT","getBodyLength","isBlob","size","isSpecCompliantForm","byteLength","isArrayBufferView","isURLSearchParams","isString","resolveBodyLength","length","toFiniteNumber","getContentLength","url","data","signal","cancelToken","timeout","onDownloadProgress","onUploadProgress","responseType","withCredentials","fetchOptions","toLowerCase","composedSignal","stopTimeout","finished","request","onFinish","unsubscribe","requestContentLength","_request","contentTypeHeader","isFormData","get","setContentType","toUpperCase","normalize","toJSON","response","isStreamResponse","options","prop","responseContentLength","responseData","findKey","Promise","resolve","reject","from","status","statusText","name","test","message","Object","assign","ERR_NETWORK","cause","code"],"mappings":"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","sourcesContent":["import platform from \"../platform/index.js\";\r\nimport utils from \"../utils.js\";\r\nimport AxiosError from \"../core/AxiosError.js\";\r\nimport composeSignals from \"../helpers/composeSignals.js\";\r\nimport {trackStream} from \"../helpers/trackStream.js\";\r\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\r\nimport progressEventReducer from \"../helpers/progressEventReducer.js\";\r\nimport resolveConfig from \"../helpers/resolveConfig.js\";\r\nimport settle from \"../core/settle.js\";\r\n\r\nconst fetchProgressDecorator = (total, fn) => {\r\n  const lengthComputable = total != null;\r\n  return (loaded) => setTimeout(() => fn({\r\n    lengthComputable,\r\n    total,\r\n    loaded\r\n  }));\r\n}\r\n\r\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\r\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\r\n\r\n// used only inside the fetch adapter\r\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\r\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\r\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\r\n);\r\n\r\nconst supportsRequestStream = isReadableStreamSupported && (() => {\r\n  let duplexAccessed = false;\r\n\r\n  const hasContentType = new Request(platform.origin, {\r\n    body: new ReadableStream(),\r\n    method: 'POST',\r\n    get duplex() {\r\n      duplexAccessed = true;\r\n      return 'half';\r\n    },\r\n  }).headers.has('Content-Type');\r\n\r\n  return duplexAccessed && !hasContentType;\r\n})();\r\n\r\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\r\n\r\nconst supportsResponseStream = isReadableStreamSupported && !!(()=> {\r\n  try {\r\n    return utils.isReadableStream(new Response('').body);\r\n  } catch(err) {\r\n    // return undefined\r\n  }\r\n})();\r\n\r\nconst resolvers = {\r\n  stream: supportsResponseStream && ((res) => res.body)\r\n};\r\n\r\nisFetchSupported && (((res) => {\r\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\r\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :\r\n      (_, config) => {\r\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\r\n      })\r\n  });\r\n})(new Response));\r\n\r\nconst getBodyLength = async (body) => {\r\n  if (body == null) {\r\n    return 0;\r\n  }\r\n\r\n  if(utils.isBlob(body)) {\r\n    return body.size;\r\n  }\r\n\r\n  if(utils.isSpecCompliantForm(body)) {\r\n    return (await new Request(body).arrayBuffer()).byteLength;\r\n  }\r\n\r\n  if(utils.isArrayBufferView(body)) {\r\n    return body.byteLength;\r\n  }\r\n\r\n  if(utils.isURLSearchParams(body)) {\r\n    body = body + '';\r\n  }\r\n\r\n  if(utils.isString(body)) {\r\n    return (await encodeText(body)).byteLength;\r\n  }\r\n}\r\n\r\nconst resolveBodyLength = async (headers, body) => {\r\n  const length = utils.toFiniteNumber(headers.getContentLength());\r\n\r\n  return length == null ? getBodyLength(body) : length;\r\n}\r\n\r\nexport default isFetchSupported && (async (config) => {\r\n  let {\r\n    url,\r\n    method,\r\n    data,\r\n    signal,\r\n    cancelToken,\r\n    timeout,\r\n    onDownloadProgress,\r\n    onUploadProgress,\r\n    responseType,\r\n    headers,\r\n    withCredentials = 'same-origin',\r\n    fetchOptions\r\n  } = resolveConfig(config);\r\n\r\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\r\n\r\n  let [composedSignal, stopTimeout] = (signal || cancelToken || timeout) ?\r\n    composeSignals([signal, cancelToken], timeout) : [];\r\n\r\n  let finished, request;\r\n\r\n  const onFinish = () => {\r\n    !finished && setTimeout(() => {\r\n      composedSignal && composedSignal.unsubscribe();\r\n    });\r\n\r\n    finished = true;\r\n  }\r\n\r\n  let requestContentLength;\r\n\r\n  try {\r\n    if (\r\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\r\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\r\n    ) {\r\n      let _request = new Request(url, {\r\n        method: 'POST',\r\n        body: data,\r\n        duplex: \"half\"\r\n      });\r\n\r\n      let contentTypeHeader;\r\n\r\n      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\r\n        headers.setContentType(contentTypeHeader)\r\n      }\r\n\r\n      if (_request.body) {\r\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(\r\n          requestContentLength,\r\n          progressEventReducer(onUploadProgress)\r\n        ), null, encodeText);\r\n      }\r\n    }\r\n\r\n    if (!utils.isString(withCredentials)) {\r\n      withCredentials = withCredentials ? 'cors' : 'omit';\r\n    }\r\n\r\n    request = new Request(url, {\r\n      ...fetchOptions,\r\n      signal: composedSignal,\r\n      method: method.toUpperCase(),\r\n      headers: headers.normalize().toJSON(),\r\n      body: data,\r\n      duplex: \"half\",\r\n      withCredentials\r\n    });\r\n\r\n    let response = await fetch(request);\r\n\r\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\r\n\r\n    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {\r\n      const options = {};\r\n\r\n      ['status', 'statusText', 'headers'].forEach(prop => {\r\n        options[prop] = response[prop];\r\n      });\r\n\r\n      const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\r\n\r\n      response = new Response(\r\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(\r\n          responseContentLength,\r\n          progressEventReducer(onDownloadProgress, true)\r\n        ), isStreamResponse && onFinish, encodeText),\r\n        options\r\n      );\r\n    }\r\n\r\n    responseType = responseType || 'text';\r\n\r\n    let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\r\n\r\n    !isStreamResponse && onFinish();\r\n\r\n    stopTimeout && stopTimeout();\r\n\r\n    return await new Promise((resolve, reject) => {\r\n      settle(resolve, reject, {\r\n        data: responseData,\r\n        headers: AxiosHeaders.from(response.headers),\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        config,\r\n        request\r\n      })\r\n    })\r\n  } catch (err) {\r\n    onFinish();\r\n\r\n    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\r\n      throw Object.assign(\r\n        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\r\n        {\r\n          cause: err.cause || err\r\n        }\r\n      )\r\n    }\r\n\r\n    throw AxiosError.from(err, err && err.code, config, request);\r\n  }\r\n});\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}