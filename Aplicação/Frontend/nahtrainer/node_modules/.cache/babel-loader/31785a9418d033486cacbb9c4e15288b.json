{"ast":null,"code":"import utils from '../utils.js';\nimport httpAdapter from './http.js';\nimport xhrAdapter from './xhr.js';\nimport fetchAdapter from './fetch.js';\nimport AxiosError from \"../core/AxiosError.js\";\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n  fetch: fetchAdapter\n};\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value\n      });\n    } catch (e) {// eslint-disable-next-line no-empty\n    }\n\n    Object.defineProperty(fn, 'adapterName', {\n      value\n    });\n  }\n});\n\nconst renderReason = reason => `- ${reason}`;\n\nconst isResolvedHandle = adapter => utils.isFunction(adapter) || adapter === null || adapter === false;\n\nexport default {\n  getAdapter: adapters => {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n    const {\n      length\n    } = adapters;\n    let nameOrAdapter;\n    let adapter;\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n      const reasons = Object.entries(rejectedReasons).map(_ref => {\n        let [id, state] = _ref;\n        return `adapter ${id} ` + (state === false ? 'is not supported by the environment' : 'is not available in the build');\n      });\n      let s = length ? reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';\n      throw new AxiosError(`There is no suitable adapter to dispatch the request ` + s, 'ERR_NOT_SUPPORT');\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n};","map":{"version":3,"sources":["C:/Users/beatr/OneDrive/Documentos/Nah Trainer/projetoaps/Aplicação/Frontend/nahtrainer/node_modules/axios/lib/adapters/adapters.js"],"names":["utils","httpAdapter","xhrAdapter","fetchAdapter","AxiosError","knownAdapters","http","xhr","fetch","forEach","fn","value","Object","defineProperty","e","renderReason","reason","isResolvedHandle","adapter","isFunction","getAdapter","adapters","isArray","length","nameOrAdapter","rejectedReasons","i","id","String","toLowerCase","undefined","reasons","entries","map","state","s","join"],"mappings":"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","sourcesContent":["import utils from '../utils.js';\r\nimport httpAdapter from './http.js';\r\nimport xhrAdapter from './xhr.js';\r\nimport fetchAdapter from './fetch.js';\r\nimport AxiosError from \"../core/AxiosError.js\";\r\n\r\nconst knownAdapters = {\r\n  http: httpAdapter,\r\n  xhr: xhrAdapter,\r\n  fetch: fetchAdapter\r\n}\r\n\r\nutils.forEach(knownAdapters, (fn, value) => {\r\n  if (fn) {\r\n    try {\r\n      Object.defineProperty(fn, 'name', {value});\r\n    } catch (e) {\r\n      // eslint-disable-next-line no-empty\r\n    }\r\n    Object.defineProperty(fn, 'adapterName', {value});\r\n  }\r\n});\r\n\r\nconst renderReason = (reason) => `- ${reason}`;\r\n\r\nconst isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;\r\n\r\nexport default {\r\n  getAdapter: (adapters) => {\r\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\r\n\r\n    const {length} = adapters;\r\n    let nameOrAdapter;\r\n    let adapter;\r\n\r\n    const rejectedReasons = {};\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      nameOrAdapter = adapters[i];\r\n      let id;\r\n\r\n      adapter = nameOrAdapter;\r\n\r\n      if (!isResolvedHandle(nameOrAdapter)) {\r\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\r\n\r\n        if (adapter === undefined) {\r\n          throw new AxiosError(`Unknown adapter '${id}'`);\r\n        }\r\n      }\r\n\r\n      if (adapter) {\r\n        break;\r\n      }\r\n\r\n      rejectedReasons[id || '#' + i] = adapter;\r\n    }\r\n\r\n    if (!adapter) {\r\n\r\n      const reasons = Object.entries(rejectedReasons)\r\n        .map(([id, state]) => `adapter ${id} ` +\r\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\r\n        );\r\n\r\n      let s = length ?\r\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\r\n        'as no adapter specified';\r\n\r\n      throw new AxiosError(\r\n        `There is no suitable adapter to dispatch the request ` + s,\r\n        'ERR_NOT_SUPPORT'\r\n      );\r\n    }\r\n\r\n    return adapter;\r\n  },\r\n  adapters: knownAdapters\r\n}\r\n"]},"metadata":{},"sourceType":"module"}