{"ast":null,"code":"export const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n};\nexport const readBytes = async function* (iterable, chunkSize, encode) {\n  for await (const chunk of iterable) {\n    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode(String(chunk)), chunkSize);\n  }\n};\nexport const trackStream = (stream, chunkSize, onProgress, onFinish, encode) => {\n  const iterator = readBytes(stream, chunkSize, encode);\n  let bytes = 0;\n  return new ReadableStream({\n    type: 'bytes',\n\n    async pull(controller) {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        controller.close();\n        onFinish();\n        return;\n      }\n\n      let len = value.byteLength;\n      onProgress && onProgress(bytes += len);\n      controller.enqueue(new Uint8Array(value));\n    },\n\n    cancel(reason) {\n      onFinish(reason);\n      return iterator.return();\n    }\n\n  }, {\n    highWaterMark: 2\n  });\n};","map":{"version":3,"sources":["C:/Users/beatr/OneDrive/Documentos/Nah Trainer/projetoaps/Aplicação/Frontend/nahtrainer/node_modules/axios/lib/helpers/trackStream.js"],"names":["streamChunk","chunk","chunkSize","len","byteLength","pos","end","slice","readBytes","iterable","encode","ArrayBuffer","isView","String","trackStream","stream","onProgress","onFinish","iterator","bytes","ReadableStream","type","pull","controller","done","value","next","close","enqueue","Uint8Array","cancel","reason","return","highWaterMark"],"mappings":"AAEA,OAAO,MAAMA,WAAW,GAAG,WAAWC,KAAX,EAAkBC,SAAlB,EAA6B;AACtD,MAAIC,GAAG,GAAGF,KAAK,CAACG,UAAhB;;AAEA,MAAI,CAACF,SAAD,IAAcC,GAAG,GAAGD,SAAxB,EAAmC;AACjC,UAAMD,KAAN;AACA;AACD;;AAED,MAAII,GAAG,GAAG,CAAV;AACA,MAAIC,GAAJ;;AAEA,SAAOD,GAAG,GAAGF,GAAb,EAAkB;AAChBG,IAAAA,GAAG,GAAGD,GAAG,GAAGH,SAAZ;AACA,UAAMD,KAAK,CAACM,KAAN,CAAYF,GAAZ,EAAiBC,GAAjB,CAAN;AACAD,IAAAA,GAAG,GAAGC,GAAN;AACD;AACF,CAhBM;AAkBP,OAAO,MAAME,SAAS,GAAG,iBAAiBC,QAAjB,EAA2BP,SAA3B,EAAsCQ,MAAtC,EAA8C;AACrE,aAAW,MAAMT,KAAjB,IAA0BQ,QAA1B,EAAoC;AAClC,WAAOT,WAAW,CAACW,WAAW,CAACC,MAAZ,CAAmBX,KAAnB,IAA4BA,KAA5B,GAAqC,MAAMS,MAAM,CAACG,MAAM,CAACZ,KAAD,CAAP,CAAlD,EAAoEC,SAApE,CAAlB;AACD;AACF,CAJM;AAMP,OAAO,MAAMY,WAAW,GAAG,CAACC,MAAD,EAASb,SAAT,EAAoBc,UAApB,EAAgCC,QAAhC,EAA0CP,MAA1C,KAAqD;AAC9E,QAAMQ,QAAQ,GAAGV,SAAS,CAACO,MAAD,EAASb,SAAT,EAAoBQ,MAApB,CAA1B;AAEA,MAAIS,KAAK,GAAG,CAAZ;AAEA,SAAO,IAAIC,cAAJ,CAAmB;AACxBC,IAAAA,IAAI,EAAE,OADkB;;AAGxB,UAAMC,IAAN,CAAWC,UAAX,EAAuB;AACrB,YAAM;AAACC,QAAAA,IAAD;AAAOC,QAAAA;AAAP,UAAgB,MAAMP,QAAQ,CAACQ,IAAT,EAA5B;;AAEA,UAAIF,IAAJ,EAAU;AACRD,QAAAA,UAAU,CAACI,KAAX;AACAV,QAAAA,QAAQ;AACR;AACD;;AAED,UAAId,GAAG,GAAGsB,KAAK,CAACrB,UAAhB;AACAY,MAAAA,UAAU,IAAIA,UAAU,CAACG,KAAK,IAAIhB,GAAV,CAAxB;AACAoB,MAAAA,UAAU,CAACK,OAAX,CAAmB,IAAIC,UAAJ,CAAeJ,KAAf,CAAnB;AACD,KAfuB;;AAgBxBK,IAAAA,MAAM,CAACC,MAAD,EAAS;AACbd,MAAAA,QAAQ,CAACc,MAAD,CAAR;AACA,aAAOb,QAAQ,CAACc,MAAT,EAAP;AACD;;AAnBuB,GAAnB,EAoBJ;AACDC,IAAAA,aAAa,EAAE;AADd,GApBI,CAAP;AAuBD,CA5BM","sourcesContent":["\r\n\r\nexport const streamChunk = function* (chunk, chunkSize) {\r\n  let len = chunk.byteLength;\r\n\r\n  if (!chunkSize || len < chunkSize) {\r\n    yield chunk;\r\n    return;\r\n  }\r\n\r\n  let pos = 0;\r\n  let end;\r\n\r\n  while (pos < len) {\r\n    end = pos + chunkSize;\r\n    yield chunk.slice(pos, end);\r\n    pos = end;\r\n  }\r\n}\r\n\r\nexport const readBytes = async function* (iterable, chunkSize, encode) {\r\n  for await (const chunk of iterable) {\r\n    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : (await encode(String(chunk))), chunkSize);\r\n  }\r\n}\r\n\r\nexport const trackStream = (stream, chunkSize, onProgress, onFinish, encode) => {\r\n  const iterator = readBytes(stream, chunkSize, encode);\r\n\r\n  let bytes = 0;\r\n\r\n  return new ReadableStream({\r\n    type: 'bytes',\r\n\r\n    async pull(controller) {\r\n      const {done, value} = await iterator.next();\r\n\r\n      if (done) {\r\n        controller.close();\r\n        onFinish();\r\n        return;\r\n      }\r\n\r\n      let len = value.byteLength;\r\n      onProgress && onProgress(bytes += len);\r\n      controller.enqueue(new Uint8Array(value));\r\n    },\r\n    cancel(reason) {\r\n      onFinish(reason);\r\n      return iterator.return();\r\n    }\r\n  }, {\r\n    highWaterMark: 2\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"module"}